/*
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * RULE 13: ERC4626 DONATION ATTACK / SHARE-PRICE MANIPULATION
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 * STATUS: ðŸ”¥ CRITICAL - $500K+ paid in last 60 days alone (Dec 2024-Jan 2025)
 *
 * Recent Payouts:
 *   - Yearn V3 vaults: $150K
 *   - Sommelier: $100K
 *   - Multiple ERC4626 wrappers: $50K-$100K each
 *   - OpenZeppelin ERC4626 advisory
 *
 * Attack Vector:
 *   1. Attacker deposits minimal assets (e.g., 1 wei) to get shares
 *   2. Attacker directly transfers (donates) large amount of assets to vault
 *   3. Share price inflates massively
 *   4. Next depositor loses funds due to rounding
 *   OR
 *   5. Attacker front-runs first depositor with donation
 *   6. Victim's deposit rounds down to 0 shares
 *   7. Attacker redeems, stealing victim's assets
 *
 * This rule catches the core vulnerability: share price manipulation via
 * direct asset transfer (donation) that doesn't mint proportional shares.
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

methods {
    // ERC4626 Core
    function totalSupply() external returns (uint256) envfree;
    function totalAssets() external returns (uint256) envfree;
    function balanceOf(address) external returns (uint256) envfree;

    // Conversion functions - THE KEY TO THIS ATTACK
    function convertToShares(uint256 assets) external returns (uint256) envfree;
    function convertToAssets(uint256 shares) external returns (uint256) envfree;

    // Deposit/Withdraw
    function deposit(uint256 assets, address receiver) external returns (uint256);
    function mint(uint256 shares, address receiver) external returns (uint256);
    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256);
    function redeem(uint256 shares, address receiver, address owner) external returns (uint256);

    // Underlying asset (for tracking donations)
    function asset() external returns (address) envfree;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// GHOST: Track share price changes
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ghost uint256 lastSharePrice {
    init_state axiom lastSharePrice == 1000000; // 1e6 precision baseline
}

ghost uint256 lastTotalAssets {
    init_state axiom lastTotalAssets == 0;
}

ghost uint256 lastTotalShares {
    init_state axiom lastTotalShares == 0;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN RULE: No Inflation Attack via Donation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

rule noInflationAttack(method f, env e, calldataarg args)
    filtered {
        f -> !f.isView &&
             f.selector != sig:deposit(uint256,address).selector &&
             f.selector != sig:mint(uint256,address).selector
    }
{
    // Capture state before
    uint256 totalSharesBefore = totalSupply();
    uint256 totalAssetsBefore = totalAssets();

    // Calculate share price before (shares per 1e18 assets)
    // Using 1e18 as reference to avoid precision loss
    uint256 sharesPerAssetBefore = totalSharesBefore > 0 ?
        convertToShares(1000000000000000000) : 1000000000000000000; // 1e18

    // Execute arbitrary function (could be direct transfer/donation)
    f(e, args);

    // Capture state after
    uint256 totalSharesAfter = totalSupply();
    uint256 totalAssetsAfter = totalAssets();

    // Calculate share price after
    uint256 sharesPerAssetAfter = totalSharesAfter > 0 ?
        convertToShares(1000000000000000000) : 1000000000000000000;

    // CRITICAL CHECK: Share price should not decrease
    // If it decreases, attacker can profit from the manipulation
    assert sharesPerAssetAfter >= sharesPerAssetBefore,
        "CRITICAL: Share price decreased - donation attack possible ($500K+ bounty)";

    // Additional check: If assets increased without proportional share increase,
    // this indicates a donation that inflated share price
    assert totalAssetsAfter > totalAssetsBefore =>
           totalSharesAfter >= totalSharesBefore,
        "CRITICAL: Assets increased without share increase - inflation attack";
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RULE: First Depositor Protection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

rule firstDepositorProtection(env e, uint256 assets, address receiver) {
    // Empty vault scenario - most vulnerable state
    require totalSupply() == 0;
    require totalAssets() == 0;
    require assets > 0;
    require receiver != 0;

    uint256 shares = deposit(e, assets, receiver);

    // First depositor MUST get shares
    assert shares > 0,
        "CRITICAL: First depositor got 0 shares - classic inflation attack vector";

    // Shares should be reasonably proportional to assets
    // At minimum, 1:1 ratio for empty vault (implementation dependent)
    assert shares >= assets / 2,
        "CRITICAL: First depositor share ratio suspicious - check for manipulation";
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RULE: Deposit After Donation Attack
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

rule depositAfterDonationSafe(env e, uint256 depositAmount, address receiver) {
    // Attacker has already donated (assets > supply * initialPrice)
    uint256 totalSharesBefore = totalSupply();
    uint256 totalAssetsBefore = totalAssets();

    // Detect suspicious state: assets much higher than expected from shares
    // This indicates a donation occurred
    require totalSharesBefore > 0;
    require totalAssetsBefore > totalSharesBefore * 2; // Suspicious: 2x inflation

    require depositAmount > 0;
    require receiver != 0;

    uint256 sharesMinted = deposit(e, depositAmount, receiver);

    // Even in inflated state, depositor should get SOME shares
    assert sharesMinted > 0,
        "CRITICAL: Depositor got 0 shares after donation - active attack";

    // Shares should represent at least some value
    uint256 sharesValue = convertToAssets(sharesMinted);
    assert sharesValue >= depositAmount / 2,
        "CRITICAL: Depositor lost >50% to rounding - donation attack in progress";
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RULE: Share Price Monotonicity (Key Invariant)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

rule sharePriceNeverDecreases(method f, env e, calldataarg args) {
    uint256 supplyBefore = totalSupply();
    uint256 assetsBefore = totalAssets();

    require supplyBefore > 0; // Only meaningful when shares exist

    // Price = assets / shares (scaled)
    mathint priceBefore = (to_mathint(assetsBefore) * 1000000000000000000) / to_mathint(supplyBefore);

    f(e, args);

    uint256 supplyAfter = totalSupply();
    uint256 assetsAfter = totalAssets();

    require supplyAfter > 0; // Still has shares

    mathint priceAfter = (to_mathint(assetsAfter) * 1000000000000000000) / to_mathint(supplyAfter);

    // Share price should never decrease (except by tiny rounding)
    // A decrease means value extraction is possible
    assert priceAfter >= priceBefore - 1,
        "CRITICAL: Share price decreased - value extraction possible";
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RULE: No Rounding Exploit on Small Deposits
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

rule noRoundingExploit(env e, address receiver) {
    uint256 smallDeposit = 1; // 1 wei - minimum possible

    require totalSupply() > 0;
    require totalAssets() > 0;
    require receiver != 0;

    // Even 1 wei deposit should either:
    // 1. Give at least 1 share, OR
    // 2. Revert (acceptable protection)

    uint256 sharesBefore = balanceOf(receiver);

    deposit@withrevert(e, smallDeposit, receiver);

    uint256 sharesAfter = balanceOf(receiver);

    // If didn't revert, must have given shares
    assert lastReverted || sharesAfter > sharesBefore,
        "HIGH: 1 wei deposit gave 0 shares without reverting - rounding exploit";
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RULE: Withdrawal Cannot Extract Extra Value
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

rule withdrawalFair(env e, uint256 shares, address receiver, address owner) {
    require shares > 0;
    require receiver != 0;
    require owner != 0;

    uint256 totalAssetsBefore = totalAssets();
    uint256 totalSharesBefore = totalSupply();

    require totalSharesBefore >= shares;

    // Expected assets for these shares (fair value)
    mathint expectedAssets = (to_mathint(totalAssetsBefore) * to_mathint(shares)) / to_mathint(totalSharesBefore);

    uint256 actualAssets = redeem(e, shares, receiver, owner);

    // Should not get more than fair share
    assert to_mathint(actualAssets) <= expectedAssets + 1, // +1 for rounding
        "CRITICAL: Withdrawal extracted more than fair value - exploit possible";
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INVARIANT: Virtual Assets/Shares Protection Check
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Many protocols add "virtual" assets/shares to prevent inflation attack
// This checks if the protection exists

rule hasInflationProtection() {
    // Empty vault
    require totalSupply() == 0;
    require totalAssets() == 0;

    // Check conversion functions in empty state
    uint256 sharesFor1Asset = convertToShares(1);
    uint256 assetsFor1Share = convertToAssets(1);

    // If both return non-zero in empty vault, virtual offset exists (protected)
    // If either returns 0, no protection
    satisfy sharesFor1Asset > 0 && assetsFor1Share > 0;

    // Note: If this satisfy fails, vault likely LACKS inflation protection
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RULE: Sandwich Attack Resistance
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

rule sandwichResistance(env e1, env e2, env e3, uint256 victimDeposit, address victim) {
    address attacker = e1.msg.sender;
    require attacker != victim;
    require victim != 0;
    require victimDeposit > 0;

    // State before attack
    uint256 attackerSharesBefore = balanceOf(attacker);

    // Step 1: Attacker front-runs with small deposit
    uint256 attackerDeposit = 1;
    deposit(e1, attackerDeposit, attacker);

    // Step 2: (Simulated) Attacker donates to inflate price
    // This would be a direct transfer, which we can't easily model
    // But we can check the impact

    // Step 3: Victim deposits
    uint256 victimShares = deposit(e2, victimDeposit, victim);

    // Step 4: Attacker withdraws
    uint256 attackerSharesAfter = balanceOf(attacker);
    uint256 attackerAssets = redeem(e3, attackerSharesAfter, attacker, attacker);

    // Attacker should not profit more than their deposit
    assert to_mathint(attackerAssets) <= to_mathint(attackerDeposit) + 1,
        "CRITICAL: Sandwich attack profitable - attacker extracted value";
}
